[
  {
    "objectID": "wip/isitrng.html",
    "href": "wip/isitrng.html",
    "title": "isitrng",
    "section": "",
    "text": "library(cowplot)\nlibrary(infer)\nlibrary(knitr)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(purrr)\nlibrary(ggplot2)\nlibrary(devtools)\n\nLoading required package: usethis\n\nlibrary(testthat)\n\n\nAttaching package: 'testthat'\n\n\nThe following object is masked from 'package:devtools':\n\n    test_file\n\n\nThe following object is masked from 'package:purrr':\n\n    is_null\n\n\nThe following object is masked from 'package:dplyr':\n\n    matches\n\n\n\nplacement &lt;- tibble(rank = c(1,1,2,3,3,4,4,4,4,4,4,4,4))\n\n\nboot &lt;- rep_sample_n(placement,size=13,reps=100000,replace = TRUE) |&gt;\n  group_by(replicate) |&gt;\n  summarise(mean = mean(rank))\nboot\n\n# A tibble: 100,000 × 2\n   replicate  mean\n       &lt;int&gt; &lt;dbl&gt;\n 1         1  3.15\n 2         2  3.23\n 3         3  3.23\n 4         4  3.08\n 5         5  3.23\n 6         6  3.54\n 7         7  3.23\n 8         8  2.69\n 9         9  3.77\n10        10  3.08\n# ℹ 99,990 more rows\n\n\n\nci &lt;- get_confidence_interval(boot, level = 0.99)\nci\n\n# A tibble: 1 × 2\n  lower_ci upper_ci\n     &lt;dbl&gt;    &lt;dbl&gt;\n1     2.38     3.92\n\n\n\nbootstrap_dist_100_plot &lt;- boot |&gt;\n  ggplot(aes(x = mean)) +\n  geom_histogram(bins=length(unique(boot$mean))) + \n  geom_vline(\n    xintercept = 2.5,\n    color = \"red\", linewidth = 1.5\n  ) +\n  geom_vline(\n    xintercept = 2.288,\n    color = \"green\", linewidth = 1.5\n  ) +\n  annotate(\"rect\",\n    xmin = ci$lower_ci[[1]], xmax = ci$upper_ci[[1]], ymin = 0, ymax = Inf,\n    fill = \"deepskyblue\",\n    alpha = 0.3\n  ) +\n  xlab(\"Placement Mean\") +\n  ylab(\"Frequency\") +\n  ggtitle(\"Bootstrap Sample Mean Distribution\")\n\n# YOUR CODE HERE\n \nbootstrap_dist_100_plot"
  },
  {
    "objectID": "wip/isitrng.html#r-markdown",
    "href": "wip/isitrng.html#r-markdown",
    "title": "isitrng",
    "section": "",
    "text": "library(cowplot)\nlibrary(infer)\nlibrary(knitr)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(purrr)\nlibrary(ggplot2)\nlibrary(devtools)\n\nLoading required package: usethis\n\nlibrary(testthat)\n\n\nAttaching package: 'testthat'\n\n\nThe following object is masked from 'package:devtools':\n\n    test_file\n\n\nThe following object is masked from 'package:purrr':\n\n    is_null\n\n\nThe following object is masked from 'package:dplyr':\n\n    matches\n\n\n\nplacement &lt;- tibble(rank = c(1,1,2,3,3,4,4,4,4,4,4,4,4))\n\n\nboot &lt;- rep_sample_n(placement,size=13,reps=100000,replace = TRUE) |&gt;\n  group_by(replicate) |&gt;\n  summarise(mean = mean(rank))\nboot\n\n# A tibble: 100,000 × 2\n   replicate  mean\n       &lt;int&gt; &lt;dbl&gt;\n 1         1  3.15\n 2         2  3.23\n 3         3  3.23\n 4         4  3.08\n 5         5  3.23\n 6         6  3.54\n 7         7  3.23\n 8         8  2.69\n 9         9  3.77\n10        10  3.08\n# ℹ 99,990 more rows\n\n\n\nci &lt;- get_confidence_interval(boot, level = 0.99)\nci\n\n# A tibble: 1 × 2\n  lower_ci upper_ci\n     &lt;dbl&gt;    &lt;dbl&gt;\n1     2.38     3.92\n\n\n\nbootstrap_dist_100_plot &lt;- boot |&gt;\n  ggplot(aes(x = mean)) +\n  geom_histogram(bins=length(unique(boot$mean))) + \n  geom_vline(\n    xintercept = 2.5,\n    color = \"red\", linewidth = 1.5\n  ) +\n  geom_vline(\n    xintercept = 2.288,\n    color = \"green\", linewidth = 1.5\n  ) +\n  annotate(\"rect\",\n    xmin = ci$lower_ci[[1]], xmax = ci$upper_ci[[1]], ymin = 0, ymax = Inf,\n    fill = \"deepskyblue\",\n    alpha = 0.3\n  ) +\n  xlab(\"Placement Mean\") +\n  ylab(\"Frequency\") +\n  ggtitle(\"Bootstrap Sample Mean Distribution\")\n\n# YOUR CODE HERE\n \nbootstrap_dist_100_plot"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "HonestCode",
    "section": "",
    "text": "An Intro to Segment Trees and Their Applicability to Database Management Systems\n\n\n\n2026\n\nanalysis\n\n\n\n\n\n\n\n\n\nJan 16, 2026\n\n\nAlexander Wen\n\n\n\n\n\n\n\n\n\n\n\n\nSparse Tables\n\n\n\ndata structures\n\n2026\n\n\n\n\n\n\n\n\n\nJan 8, 2026\n\n\nAlexander Wen\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/database-segment-tree/index.html",
    "href": "posts/database-segment-tree/index.html",
    "title": "An Intro to Segment Trees and Their Applicability to Database Management Systems",
    "section": "",
    "text": "It goes without saying that PostgreSQL, MondoDB, Redis, and all other database management systems require efficient methods for managing and querying their stored databases. A similarity between nearly all of these database management systems is that they make use of one of the most flexible and powerful data structures: the segment tree."
  },
  {
    "objectID": "posts/database-segment-tree/index.html#a-segment-tree-example",
    "href": "posts/database-segment-tree/index.html#a-segment-tree-example",
    "title": "An Intro to Segment Trees and Their Applicability to Database Management Systems",
    "section": "A Segment Tree Example",
    "text": "A Segment Tree Example\nTo demonstrate the effectiveness of the segment tree, let’s use it in an example, that acts as a continuation from last week’s post about sparse tables. After John Code (our hiker from last week) maps out a mountain range and all of the various peaks, he ends up with a new set of data indicating the number of people that visited each landmark over the past week:\n\n\n\nMore mountain measurements.\n\n\nThese are the measurements expressed in an array:\n\n\n\nIndex #\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\nNumber of tourists\n1\n2\n0\n3\n1\n4\n0\n2\n\n\n\nNow John is interested in which parts of the mountain range are the most popular. To do this, he queries the sum of various subarrays. For example, the subarray representing the part of the mountain range from landmark 3 to 5 saw \\(0 + 3 + 1 = 4\\) people visit last week, whereas the subarray representing the part of the mountain range from landmark 1 to 4 saw \\(1 + 2 + 0 + 3 = 6\\) people visit last week. He then records all of these measurements in a database, and now let’s see how such queries can be computed efficiently.\nTo create the segment tree, we are going to compute the sums for only some of the subarrays. First, we create a node for every single measurement made, representing the trivial sum values for every subarray of length 1:\n\n\n\nBase step of segment tree creation.\n\n\nNow we compute the sum values for the subarrays of length 2 by summing every pair of consecutive nodes like below:\n\n\n\nNode combining process\n\n\nThis new row now contains the sums for the subarrays with indexes going 1 to 2, 3 to 4, 5 to 6, and 7 to 8. Repeat this step with the new nodes created to get the sum values for subarrays of length 4:\n\n\n\nRepeating the previous step\n\n\nAnd now finally with the two nodes for the subarrays with indexes going 1 to 4 and 5 to 8, create the top layer of the segment tree representing the sum value for subarrays of length 8 (ie. the entire array):\n\n\n\nThe full segment tree.\n\n\nThis segment tree can now be used to compute the sum of any subarray by choosing nodes greedily, meaning that the nodes that cover the largest subarrays are chosen first to minimize the number of nodes involved. For instance, if the sum of the subarray from index 1 to 7 was to be computed:\n\n\n\nExample of the segment tree in use.\n\n\nThe yellow nodes indicate nodes that are only partially included in the subarray range. These nodes are not included in the sum but are instead searched deeper to their child nodes. The green nodes indicate nodes that are fully covered by the subarray range, so for maximum efficiency, these nodes are added to the sum and no further searching is required. For this example, the sum of the subarray from index 1 to 7 is \\(6 + 5 + 0 = 11\\).\nWith efficient node selection, at most one node from each layer is going to be selected. This means in a much larger case, if John Code’s robot made a million measurements in total, then because the number of nodes in each layer is divided by two each time, such a segment tree would have only 21 such layers, meaning that ANY subarray sum for an array of one million values can be computed by just adding at most 21 values together! A segment tree of that size would consist of \\(1000000 + 500000 + 250000 + ... + 2 + 1 \\approx 2000000\\) nodes, so while there is a substantial precomputation cost, if multiple subarray sums are required, this is a much faster method than burte forcing every query. Generally, for an array of \\(n\\) elements, a segment tree will create roughly \\(2n\\) nodes, and will require summing up at most \\(\\text{log}_2(n)\\) nodes to compute a subarray sum. In big-O notation, this means the amount of time to create a segment tree scales linearly with the size of the array and can be represented as \\(O(n)\\), while the time needed to complete a single query scales logarithmically with the size of the array and can be represented as \\(O(\\log n)\\)."
  },
  {
    "objectID": "posts/database-segment-tree/index.html#database-usability-of-segment-trees",
    "href": "posts/database-segment-tree/index.html#database-usability-of-segment-trees",
    "title": "An Intro to Segment Trees and Their Applicability to Database Management Systems",
    "section": "Database Usability of Segment Trees",
    "text": "Database Usability of Segment Trees\nTechnically, there are simpler methods to finding the sum of any subarray that are equally as fast or even faster, such as prefix sums. However, suppose that John later finds there was an error in his data, and that landmark 5 actually had a lot more people there last week, updating the array to something like below:\n\n\n\nIndex #\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\nNumber of tourists\n1\n2\n0\n3\n100\n4\n0\n2\n\n\n\nThese data updates can be common in a database context, and what makes segment trees useful is how they handle these changes. First, we highlight all nodes that are affected by this change in the previous segment tree red. These nodes include the base node tracking the sum of the subarray from index 5 to 5 in the bottom layer, and each subsequent parent node up to the top.\n\n\n\nNodes that are affected by index 5 changing from 1 to 100.\n\n\nNow starting from the bottom node in this tree, update each node: - The sum of the subarray from index 5 to 5 is now 100 (previously 1) - The sum of the subarray from index 5 to 6 is now 104 (100 + 4) - The sum of the subarray from index 5 to 8 is now 106 (104 + 2) - The sum of the subarray from index 1 to 8 is now 112 (6 + 106)\n\n\n\nUpdated segment tree.\n\n\nNow with this updated segment tree, the subarray sum queries can be computed in the same way as before. Even with a much larger tree, the number of nodes that need to be updated will always be equal to the number of layers in the tree, thus meaning that the amount of time needed to perform such an update scales logarithmically with the array size. This means that this is roughly as fast as the \\(O(\\log n)\\) operation used for finding a subarray sum."
  },
  {
    "objectID": "posts/database-segment-tree/index.html#conclusion",
    "href": "posts/database-segment-tree/index.html#conclusion",
    "title": "An Intro to Segment Trees and Their Applicability to Database Management Systems",
    "section": "Conclusion",
    "text": "Conclusion\nIn short, segment trees are a data structure based solution that explains how database management systems are capable of processing database queries in an efficient manner. The subarray sum problem is just one of the many applicable uses of segment trees, and further explanation as well as a code implementation of the structure can be found on cp-algorithms, which is one of the largest information bases for various data structure and algorithmic concepts used in competitive programming."
  },
  {
    "objectID": "posts/sparse-table/index.html",
    "href": "posts/sparse-table/index.html",
    "title": "Sparse Tables",
    "section": "",
    "text": "Suppose a hiker is mapping out a mountain range. They walk across the mountain and record their current altitude in meters at important landmarks in this diagram:\n\n\n\nVarious mountain measurements.\n\n\nThese measurements can then be expressed in an array:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIndex #\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\nAltitude in meters\n800\n400\n700\n1000\n1300\n1600\n1200\n900\n\n\n\nFrom this array, the highest altitude in this entire mountain range is 1300 meters. But some travellers may only traverse part of this mountain range; for example, someone that travels from landmark 1 to 4 reaches a maximum altitude of 1000 meters, and another person who travels from landmark 7 to 8 reaches a maximum altitude of 1200 meters. These continuous segments are referred to as subarrays.\nNow imagine that many tourists ask about the highest altitude they can reach by traversing an arbitrary segment of this mountain range. Thus, a method to find the maximum value of any subarray in this measurement array is required, and each question must be answerable in a practically instant amount of time. An initial solution is to build a table with the maximum altitudes reached for every subarray from index \\(X\\) to \\(Y\\) like below:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nX = 1\nX = 2\nX = 3\nX = 4\nX = 5\nX = 6\nX = 7\nX = 8\n\n\n\n\nY = 1\n800\n-\n-\n-\n-\n-\n-\n-\n\n\nY = 2\n800\n400\n-\n-\n-\n-\n-\n-\n\n\nY = 3\n800\n700\n700\n-\n-\n-\n-\n-\n\n\nY = 4\n1000\n1000\n1000\n1000\n-\n-\n-\n-\n\n\nY = 5\n1300\n1300\n1300\n1300\n1300\n-\n-\n-\n\n\nY = 6\n1600\n1600\n1600\n1600\n1600\n1600\n-\n-\n\n\nY = 7\n1600\n1600\n1600\n1600\n1600\n1600\n1200\n-\n\n\nY = 8\n1600\n1600\n1600\n1600\n1600\n1600\n1200\n900\n\n\n\nAny tourist’s query can now be answered by instantly looking up the specific subarray in this table. This method is effective, but also tedious because for any positive value \\(C\\), increasing the length of this array by a factor of \\(C\\) will increase the number of subarrays computed by a factor of \\(C^2\\). In this example, all 36 possible subarrays are computed, which is manageable. But suppose on larger scale, a robot took far more measurements on the mountain, such as a million. This table method would then have to compute the maximum value of each of roughly 5 trillion subarrays, which is infeasible even with a computer.\nThere is a more efficient way because not every subarray maximum value has to be literally computed. For example, knowing that maximum values for the subarrays from index 1 to 4 and index 3 to 6 to be 1000 and 1600 respectively is enough to conclude that the maximum value for the subarray from index 1 to 6 must be 1600. This is because every index from 1 to 6 is in at least one of these subarrays, thus the maximum value for the entire subarray must be the higher of 1000 and 1600. This important observation motivates the following sparse table.\nLet \\(L\\) be the length of a subarray. Start by “computing” the maximum value of every single element subarray.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSubarray length\nX = 1\nX = 2\nX = 3\nX = 4\nX = 5\nX = 6\nX = 7\nX = 8\n\n\n\n\nL = 1\n800\n400\n700\n1000\n1300\n1600\n1200\n900\n\n\n\nThe maximum of the subarray of length \\(L\\) from index \\(X\\) to \\(X+L-1\\) inclusive is equal to the higher of the maximums for the subarray from index \\(X\\) to \\(X+L/2-1\\) and index \\(X+L/2\\) to \\(X+L-1\\). The computed subarray maximums for \\(L = 1\\) can then be used to compute the subarray maximums for \\(L = 2\\):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSubarray length\nX = 1\nX = 2\nX = 3\nX = 4\nX = 5\nX = 6\nX = 7\nX = 8\n\n\n\n\nL = 1\n800\n400\n700\n1000\n1300\n1600\n1200\n900\n\n\nL = 2\n800\n700\n1000\n1300\n1600\n1600\n1200\n-\n\n\n\nThis information can then be used to compute the subarray maximums for \\(L = 4\\):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSubarray length\nX = 1\nX = 2\nX = 3\nX = 4\nX = 5\nX = 6\nX = 7\nX = 8\n\n\n\n\nL = 1\n800\n400\n700\n1000\n1300\n1600\n1200\n900\n\n\nL = 2\n800\n700\n1000\n1300\n1600\n1600\n1200\n-\n\n\nL = 4\n1000\n1300\n1600\n1600\n1600\n-\n-\n-\n\n\n\nAnd lastly in this case, \\(L = 8\\) (further steps would use larger powers of 2 for \\(L\\)):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSubarray length\nX = 1\nX = 2\nX = 3\nX = 4\nX = 5\nX = 6\nX = 7\nX = 8\n\n\n\n\nL = 1\n800\n400\n700\n1000\n1300\n1600\n1200\n900\n\n\nL = 2\n800\n700\n1000\n1300\n1600\n1600\n1200\n-\n\n\nL = 4\n1000\n1300\n1600\n1600\n1600\n-\n-\n-\n\n\nL = 8\n1600\n-\n-\n-\n-\n-\n-\n-\n\n\n\nThe maximum of any subarray from index \\(A\\) to \\(B\\) can then be computed using this sparse table in 3 steps:\n\nCompute \\(N\\), the length of the subarray. (\\(N = B - A + 1\\))\nDetermine \\(M\\), the largest power of 2 (1, 2, 4, 8, 16, 32…) satisfying \\(M \\leq N\\).\nLook in the row \\(L = M\\) and choose the larger of the values in columns \\(X = A\\) and \\(X = B - M + 1\\), representing the subarrays from index \\(A\\) to \\(A + M - 1\\) and index \\(B - M + 1\\) to \\(B\\). These subarrays are guaranteed to cover every index from \\(A\\) to \\(B\\).\n\nAs an example, suppose a tourist wanted to know the highest altitude (maximum) between landmarks 2 to 4. Use the method to determine the maximum of the subarray from index 2 to 4:\n\n\\(N = 4 - 2 + 1\\) =&gt; \\(N = 3\\)\n\\(M = 2\\) (largest power of 2 less than or equal to 3)\nValue in \\(L = 2, X = 2\\) is 700; value in \\(L = 2, X = 4 - 2 + 1 = 3\\) is 1000. Thus the maximum altitude between landmarks 2 to 4 is 1000.\n\nWith the sparse table, only 21 total subarrays have their maximum computed, compared to 36 with the naive table approach. Where this efficiency is more pronounced is with more measurements; for any positive value \\(C\\), increasing the length of the array by a factor of \\(C\\) will now only increase the number of subarrays computed by a factor of \\(C\\text{log}(C)\\). Going back to the robot scenario, if the array consisted of a million values, the number of maximums for subarrays computed would decrease from roughly 5 trillion with a naive table to 19 million with a sparse table."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  }
]