[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/sparse-table/index.html",
    "href": "posts/sparse-table/index.html",
    "title": "Sparse Tables",
    "section": "",
    "text": "Suppose a hiker is mapping out a mountain range. They walk across the mountain and record their current altitude in meters at important landmarks in this diagram:\n\n\n\nVarious mountain measurements.\n\n\nThese measurements can then be expressed in an array:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIndex #\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\nAltitude in meters\n800\n400\n700\n1000\n1300\n1600\n1200\n900\n\n\n\nFrom this array, the highest altitude in this entire mountain range is 1300 meters. But some travellers may only traverse part of this mountain range; for example, someone that travels from landmark 1 to 4 reaches a maximum altitude of 1000 meters, and another person who travels from landmark 7 to 8 reaches a maximum altitude of 1200 meters. These continuous segments are referred to as subarrays.\nNow imagine that many tourists ask about the highest altitude they can reach by traversing an arbitrary segment of this mountain range. Thus, a method to find the maximum value of any subarray in this measurement array is required, and each question must be answerable in a practically instant amount of time. An initial solution is to build a table with the maximum altitudes reached for every subarray from index \\(X\\) to \\(Y\\) like below:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nX = 1\nX = 2\nX = 3\nX = 4\nX = 5\nX = 6\nX = 7\nX = 8\n\n\n\n\nY = 1\n800\n-\n-\n-\n-\n-\n-\n-\n\n\nY = 2\n800\n400\n-\n-\n-\n-\n-\n-\n\n\nY = 3\n800\n700\n700\n-\n-\n-\n-\n-\n\n\nY = 4\n1000\n1000\n1000\n1000\n-\n-\n-\n-\n\n\nY = 5\n1300\n1300\n1300\n1300\n1300\n-\n-\n-\n\n\nY = 6\n1600\n1600\n1600\n1600\n1600\n1600\n-\n-\n\n\nY = 7\n1600\n1600\n1600\n1600\n1600\n1600\n1200\n-\n\n\nY = 8\n1600\n1600\n1600\n1600\n1600\n1600\n1200\n900\n\n\n\nAny tourist’s query can now be answered by instantly looking up the specific subarray in this table. This method is effective, but also tedious because for any positive value \\(C\\), increasing the length of this array by a factor of \\(C\\) will increase the number of subarrays computed by a factor of \\(C^2\\). In this example, all 36 possible subarrays are computed, which is manageable. But suppose on larger scale, a robot took far more measurements on the mountain, such as a million. This table method would then have to compute the maximum value of each of roughly 5 trillion subarrays, which is infeasible even with a computer.\nThere is a more efficient way because not every subarray maximum value has to be literally computed. For example, knowing that maximum values for the subarrays from index 1 to 4 and index 3 to 6 to be 1000 and 1600 respectively is enough to conclude that the maximum value for the subarray from index 1 to 6 must be 1600. This is because every index from 1 to 6 is in at least one of these subarrays, thus the maximum value for the entire subarray must be the higher of 1000 and 1600. This important observation motivates the following sparse table.\nLet \\(L\\) be the length of a subarray. Start by “computing” the maximum value of every single element subarray.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSubarray length\nX = 1\nX = 2\nX = 3\nX = 4\nX = 5\nX = 6\nX = 7\nX = 8\n\n\n\n\nL = 1\n800\n400\n700\n1000\n1300\n1600\n1200\n900\n\n\n\nThe maximum of the subarray of length \\(L\\) from index \\(X\\) to \\(X+L-1\\) inclusive is equal to the higher of the maximums for the subarray from index \\(X\\) to \\(X+L/2-1\\) and index \\(X+L/2\\) to \\(X+L-1\\). The computed subarray maximums for \\(L = 1\\) can then be used to compute the subarray maximums for \\(L = 2\\):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSubarray length\nX = 1\nX = 2\nX = 3\nX = 4\nX = 5\nX = 6\nX = 7\nX = 8\n\n\n\n\nL = 1\n800\n400\n700\n1000\n1300\n1600\n1200\n900\n\n\nL = 2\n800\n700\n1000\n1300\n1600\n1600\n1200\n-\n\n\n\nThis information can then be used to compute the subarray maximums for \\(L = 4\\):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSubarray length\nX = 1\nX = 2\nX = 3\nX = 4\nX = 5\nX = 6\nX = 7\nX = 8\n\n\n\n\nL = 1\n800\n400\n700\n1000\n1300\n1600\n1200\n900\n\n\nL = 2\n800\n700\n1000\n1300\n1600\n1600\n1200\n-\n\n\nL = 4\n1000\n1300\n1600\n1600\n1600\n-\n-\n-\n\n\n\nAnd lastly in this case, \\(L = 8\\) (further steps would use larger powers of 2 for \\(L\\)):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSubarray length\nX = 1\nX = 2\nX = 3\nX = 4\nX = 5\nX = 6\nX = 7\nX = 8\n\n\n\n\nL = 1\n800\n400\n700\n1000\n1300\n1600\n1200\n900\n\n\nL = 2\n800\n700\n1000\n1300\n1600\n1600\n1200\n-\n\n\nL = 4\n1000\n1300\n1600\n1600\n1600\n-\n-\n-\n\n\nL = 8\n1600\n-\n-\n-\n-\n-\n-\n-\n\n\n\nThe maximum of any subarray from index \\(A\\) to \\(B\\) can then be computed using this sparse table in 3 steps:\n\nCompute \\(N\\), the length of the subarray. (\\(N = B - A + 1\\))\nDetermine \\(M\\), the largest power of 2 (1, 2, 4, 8, 16, 32…) satisfying \\(M \\leq N\\).\nLook in the row \\(L = M\\) and choose the larger of the values in columns \\(X = A\\) and \\(X = B - M + 1\\), representing the subarrays from index \\(A\\) to \\(A + M - 1\\) and index \\(B - M + 1\\) to \\(B\\). These subarrays are guaranteed to cover every index from \\(A\\) to \\(B\\).\n\nAs an example, suppose a tourist wanted to know the highest altitude (maximum) between landmarks 2 to 4. Use the method to determine the maximum of the subarray from index 2 to 4:\n\n\\(N = 4 - 2 + 1\\) =&gt; \\(N = 3\\)\n\\(M = 2\\) (largest power of 2 less than or equal to 3)\nValue in \\(L = 2, X = 2\\) is 700; value in \\(L = 2, X = 4 - 2 + 1 = 3\\) is 1000. Thus the maximum altitude between landmarks 2 to 4 is 1000.\n\nWith the sparse table, only 21 total subarrays have their maximum computed, compared to 36 with the naive table approach. Where this efficiency is more pronounced is with more measurements; for any positive value \\(C\\), increasing the length of the array by a factor of \\(C\\) will now only increase the number of subarrays computed by a factor of \\(C\\text{log}(C)\\). Going back to the robot scenario, if the array consisted of a million value, the number of maximums for subarrays computed would decrease from roughly 5 trillion with a naive table to 19 million with a sparse table."
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "template",
    "section": "",
    "text": "Post With Code\n\n\n\nnews\n\ncode\n\nanalysis\n\n\n\n\n\n\n\n\n\nJan 14, 2026\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nJan 11, 2026\n\n\nTristan O’Malley\n\n\n\n\n\n\n\n\n\n\n\n\nSparse Tables\n\n\n\ndata structures\n\n2026\n\n\n\n\n\n\n\n\n\nJan 8, 2026\n\n\nAlexander Wen\n\n\n\n\n\nNo matching items"
  }
]