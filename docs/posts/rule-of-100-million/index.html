<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Alexander Wen">
<meta name="dcterms.date" content="2026-01-24">

<title>Rule of 100 Million: Estimating Big-O Runtime Expectations – HonestCode</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">HonestCode</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/alxwen711"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Rule of 100 Million: Estimating Big-O Runtime Expectations</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">competitive programming</div>
                <div class="quarto-category">2026</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Alexander Wen </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 24, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>There is a reason why experienced competitive programmers can look at a problem and then within seconds, be able to determine a basic idea of the solution. All problems in competitive programming require an understanding of how fast an algorithm must be to solve it, and within each problem statement there is important snippets that can immediately help you perform a basic time complexity analysis.</p>
<section id="a-quick-review-of-big-o-notation" class="level2">
<h2 class="anchored" data-anchor-id="a-quick-review-of-big-o-notation">A Quick Review of Big-O Notation</h2>
<p>Time complexity is represented through Big-O Notation, which in mathematical terms, states that a function <span class="math inline">\(f(x)\)</span> is equal to <span class="math inline">\(O(g(x))\)</span> if and only if</p>
<p><span class="math display">\[
\exists M,x_0 \text{ s.t. } |f(x)| \leq Mg(x), \forall x \geq x_0
\]</span></p>
<p>To explain this more simply, an algorithm has a time complexity of <span class="math inline">\(O(f(n))\)</span> if for some arbritary minimal input size, when increasing the input size by a factor of <span class="math inline">\(n\)</span>, the runtime of the algorithm increases by a factor of <span class="math inline">\(f(n)\)</span>. In the context of competitive programming, the runtime is usually approximated by the number of basic operations performed, which are general computer operations (adding, subtracting, conditionals) that have a near instant and constant <span class="math inline">\(O(1)\)</span> amount time to complete. (Technically running <code>time.sleep(100)</code> in Python would be a <span class="math inline">\(O(1)\)</span> operation since it will always pause the program for 100 seconds, but it can hardly be called instantaneous, so while it is a constant operation, it is not basic.) Basic operations can also include array index lookup, adding two numbers, modulo division, and assigning variables.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Dictionary additions and lookups can also be considered basic operations, but this assumes there are an insignifcant number of collisions in the hashing function. Especially within CodeForces there are scenarios where users can design test cases to intentionally cause many such collisions resulting in set/dict lookup to take <span class="math inline">\(O(n)\)</span> time per operation. <a href="https://codeforces.com/blog/entry/62393">https://codeforces.com/blog/entry/62393</a> contains a very robust setup at the end to make a custom hash that is immune to such hacks, but from practice, even small adjustments to the basic hash function used are usually enough.</p>
</div>
</div>
<p>Now that this overview has been taken care of, the rule of 100 million can be summed up by the following subtitle:</p>
</section>
<section id="assume-at-most-100-million-operations-per-second" class="level2">
<h2 class="anchored" data-anchor-id="assume-at-most-100-million-operations-per-second">Assume at most 100 Million Operations Per Second</h2>
<ul>
<li>state rule 100 million -&gt; 1 second</li>
</ul>
<p><strong>Formally, to estimate runtime, we can assume that a program can complete up to 100 million basic operations per second.</strong></p>
<p>In practice, assuming a program will perform 100 million operations per second is fairly optimistic. Most problems are designed to allow quite a bit of leniency up to roughly a factor of 3, so assuming about 30 million operations per second for C++ is a safe estimate. As for Python, this number drops to around 10 million operations per second, but having done many contests using Python, the number of times this actually affected me where an algorithm in C++ passes but that same one in Python fails is maybe once.</p>
<p>Knowing this, let’s use a few example statements to estimate the maximum runtime complexity allowed:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="global27c.png" class="img-fluid figure-img"></p>
<figcaption>Source: Global Round 27 C (https://codeforces.com/contest/2035/problem/C)</figcaption>
</figure>
</div>
<p>Here we observe that the maximum value of <span class="math inline">\(n\)</span> is 200000, and that we have 2 seconds in this problem. <span class="math inline">\(200000^2 = 4*10^{10} &gt; 2*10^8\)</span>, so we can safely assume an <span class="math inline">\(O(n^2)\)</span> algorithm is not going to work. On the other hand, <span class="math inline">\(200000 &lt; 2*10^8\)</span>, so we can be very sure that an <span class="math inline">\(O(n)\)</span> algorithm can work. The tightest possible bound here would be <span class="math inline">\(O(n \log^2 n)\)</span>; computationally this works out to about <span class="math inline">\(\log(200000)^2*200000 \approx\)</span> 62 million operations, which is under the 100 million operation per second assumption, but using 30 million operations per second as a safe C++ or optimistic Python estimate makes this complexity iffy. In actual practice, <span class="math inline">\(O(n \log^2 n)\)</span> complexities are quite rare and this problem would most likely be expecting a time complexity of <span class="math inline">\(O(n \log n)\)</span> or better given these constraints.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="global27f.png" class="img-fluid figure-img"></p>
<figcaption>Source: Global Round 27 F (https://codeforces.com/contest/2035/problem/F)</figcaption>
</figure>
</div>
<p>In this case, the maximum value of <span class="math inline">\(n\)</span> is 2000, and that we have 4 seconds in this problem. This time a <span class="math inline">\(O(n^2)\)</span> algorithm will be possible because <span class="math inline">\(2000^2 = 4*10^{6} &lt; 4*10^8\)</span>. It is also worth noting that usually Codeforces problems have 1 or 2 second time limits, in the rare cases where a problem has 4 seconds allotted to it, it usualy means higher time complexities can be possible; in this case, <span class="math inline">\(O(n^2 \log n)\)</span> (roughly 44 million) and even <span class="math inline">\(O(n^{2.5})\)</span> (roughly 180 million) are possible time complexities for this solution. Especially on harder problems like this one, these are cases where more complex runtime algorithms can be possible, as the intended solution does have a <span class="math inline">\(O(n^2 \log n)\)</span> solution.</p>
<p>Below is a table of many of the more common runtime possibilities, and a rough estimate for the maximum input size <span class="math inline">\(n\)</span> for which an algorithm should reasonably be able to pass in 1 second:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 21%">
<col style="width: 28%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>Time Complexity</th>
<th>Maximum n per second</th>
<th>Examples</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>O(1)</strong>, O(log n)</td>
<td><span class="math inline">\(n \\leq 10^{18}\)</span></td>
<td>Basic operations, binary search</td>
</tr>
<tr class="even">
<td>O(sqrt n)</td>
<td><span class="math inline">\(n \\leq 10^{14}\)</span></td>
<td>Trial division primality test</td>
</tr>
<tr class="odd">
<td><strong>O(n)</strong></td>
<td><span class="math inline">\(n \\leq 10^7\)</span></td>
<td>Maximum of an array</td>
</tr>
<tr class="even">
<td><strong>O(n log n)</strong></td>
<td><span class="math inline">\(n \\leq 10^6\)</span></td>
<td>Sorting algorithms</td>
</tr>
<tr class="odd">
<td>O(n log^2 n)</td>
<td><span class="math inline">\(n \\leq 200000\)</span></td>
<td>Query type problems on segment tree</td>
</tr>
<tr class="even">
<td>O(n sqrt n)</td>
<td><span class="math inline">\(n \\leq 50000\)</span></td>
<td>Sqrt decomposition, Mo’s algorithm</td>
</tr>
<tr class="odd">
<td><strong>O(n^2)</strong></td>
<td><span class="math inline">\(n \\leq 3000\)</span></td>
<td>Brute force subarray sums</td>
</tr>
<tr class="even">
<td>O(n^2 log n)</td>
<td><span class="math inline">\(n \\leq 1000\)</span></td>
<td>Niche dp cases, very rare</td>
</tr>
<tr class="odd">
<td><strong>O(n^3)</strong></td>
<td><span class="math inline">\(n \\leq 300\)</span></td>
<td>Floyd-Warshall</td>
</tr>
<tr class="even">
<td>O(n^4)</td>
<td><span class="math inline">\(n \\leq 60\)</span></td>
<td>4D DP</td>
</tr>
<tr class="odd">
<td>O(2^n)</td>
<td><span class="math inline">\(n \\leq 25\)</span></td>
<td>Brute force on all subsets</td>
</tr>
<tr class="even">
<td>O(n!)</td>
<td><span class="math inline">\(n \\leq 11\)</span></td>
<td>Brute force on all permutations</td>
</tr>
</tbody>
</table>
<p>This table is not comprehensive, but covers just about every time complexity I have observed. In actuality, the bolded ones are the most common time complexities used in problems and are thus the most important to remember.</p>
</section>
<section id="exceptions-where-slowest-allowed-fastest-possible" class="level2">
<h2 class="anchored" data-anchor-id="exceptions-where-slowest-allowed-fastest-possible">Exceptions Where Slowest Allowed != Fastest Possible</h2>
<p>The above table can be used accurately for the slowest possible algorithms a problem will accept. For the most part, this table also provides a decent estimation of what the time complexity actually is, but there are cases where a significantly faster solution is possible than what the input size implies.</p>
<section id="codeforce-div-234-problem-a" class="level3">
<h3 class="anchored" data-anchor-id="codeforce-div-234-problem-a">Codeforce Div 2/3/4 Problem A</h3>
<p>The point of a problem A on a Codeforces contest is so that everyone (or least almost everyone) is able to solve at least one problem on a Codeforces contest. In divison 1 contests, Problem A can be fairly challenging and thus have a reasonable time complexity estimation by it’s maximum allowable algorithm, but otherwise, many of these problems are created without consideration of optimizing the time complexity of the solution.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="1074a.png" class="img-fluid figure-img"></p>
<figcaption>Source: Codeforces Round 1074 Div. 4 A (https://codeforces.com/contest/2185/problem/A)</figcaption>
</figure>
</div>
<p>In this case, we notice that the maximum <span class="math inline">\(n\)</span> value in a testcase is 20. Does that mean that the solution to this introductory problem has a <span class="math inline">\(O(2^n)\)</span> time complexity? Well you could make a solution that does, but obviously there’s faster! If we read the question carefully, we can conclude that <em>every</em> positive integer is a perfect root because <span class="math inline">\(\sqrt{x^2} = x\)</span> and <span class="math inline">\(x^2\)</span> uniquely exists for every positive integer. So all we’d have to do is output <span class="math inline">\(n\)</span> unique numbers for each testcase, which is an <span class="math inline">\(O(n)\)</span> algorithm.</p>
</section>
<section id="on3-estimates-and-longer" class="level3">
<h3 class="anchored" data-anchor-id="on3-estimates-and-longer"><span class="math inline">\(O(n^3)\)</span> Estimates and Longer</h3>
<p>Cases where the estimated runtime can be at least <span class="math inline">\(O(n^3)\)</span> usualy mean the runtime is this long, especially on harder problems. But there are cases where the solution can be surprisingly faster, as one of these cases occurred to me recently to inspire the creation of this post.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="1073b2.png" class="img-fluid figure-img"></p>
<figcaption>Source: Codeforces Round 1073 Div. 1 B2 (https://codeforces.com/contest/2190/problem/B2)</figcaption>
</figure>
</div>
<p>With this case, a time complexity as high as even <span class="math inline">\(O(n^4)\)</span> is possible because with a maximum <span class="math inline">\(n\)</span> value of 100, <span class="math inline">\(100^4 = 10^8 &lt; 2 * 10^8\)</span> for a 2 second problem. Furthermore, from my initial attempts on this problem using a dynamic programming approach, I roughly computed that there was closer to around 12.5 million basic operations needed when <span class="math inline">\(n = 100\)</span>, so even if I was using Python, a <span class="math inline">\(O(n^4)\)</span> idea was possible, and I assumed that the solution for this problem really was no faster than <span class="math inline">\(O(n^4)\)</span>.</p>
<p>What then proceeded to follow was 14 Time Limit Exceeded verdicts of complete and total agony as this contest dropped me out of the Candidate Master ranking on Codeforces. <a href="https://codeforces.com/contest/2190/submission/358366032">Here is a link to my last solution with a O(n^4) attempt where you can try and understand what exactly I was thinking.</a>.</p>
<p>From the editorial, there is a <span class="math inline">\(O(n^3)\)</span> approach to this that can be optimized further to the <span class="math inline">\(O(n^2)\)</span> algorithm I eventually submitted for upsolving, showing that the input limits are only absolute in determining the slowest possible solution, and not the actual fastest possible solution. I won’t explain the reasoning too extensively as I don’t want to provide spoilers for the problem and <a href="https://codeforces.com/blog/entry/150256">the editorial</a> is effective for explaning the solution, but as for an exercise for the reader, try to understand how the observations made in my slow <span class="math inline">\(O(n^4)\)</span> solution can be simplified greatly to create an <span class="math inline">\(O(n^3)\)</span> or better algorithm.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
How Can My O(n^4) Solution Be Faster? (Spoilers for Round 1073 Problem B2)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>The main slowdown is the dp setup used, where I am tracking the last and second last occurances of <code>(</code>, the first occurance of <code>)</code>, the count of <code>(</code> - count of <code>)</code>, and the length of the bracket subsequence being considered. Furthermore, I observe that the bracket sequence is valid (ie. the score is not 0) only if the count of <code>(</code> - count of <code>)</code> is 0 AND the second last occurrance of <code>(</code> is after the first occurance of <code>)</code>. This means this complex occurance tracking nonsense can be simplified to checking if the subsequence <code>)((</code> exists the created subsequence or not.</p>
<p>To tell if <code>)((</code> exists, all that needs to be done is to create a counter <code>x</code> which starts at 0. If a <code>)</code> is added to the subsequence and <code>x</code> is 0, then <code>x</code> is increased to 1. If <code>(</code> is added to the subsequence and <code>x</code> is 1 or 2, <code>x</code> is increased by 1. Otherwise, <code>x</code> remains as is. Then if this counter <code>x</code> ends up at 3, then the subsequence <code>)((</code> exists. This means the only things needed to track in the dp are this counter, the count of <code>(</code> - count of <code>)</code>, and the length of the bracket subsequence. This then makes a <span class="math inline">\(O(n^3)\)</span> solution possible.</p>
<p>For the <span class="math inline">\(O(n^2)\)</span> solution, another observation (which I somehow did end up making even in the <span class="math inline">\(O(n^4)\)</span> attempts) is that the score of any bracket sequence will always be either 0 or <span class="math inline">\(n-2\)</span>, where <span class="math inline">\(n\)</span> is the length of the sequence. This then means that only information needed to be tracked for computing the answer are the number of bracket sequences with the specific counter value and count of <code>(</code> - count of <code>)</code> and their combined lengths, which is possibe in <span class="math inline">\(O(n^2)\)</span>. My upsolved solution is an example of this. (<a href="https://codeforces.com/contest/2190/submission/358384748">https://codeforces.com/contest/2190/submission/358384748</a>)</p>
</div>
</div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>